Contents:

1. Prerequisites
2. Compilation and Execution
3. Building visual graphs
4. Approaches for each phase
5. Limitations

1. Prerequisites:
=================
To build the visual graphs as specified in Section -3, graphviz needs to be installed.
The visual representation reduces the trouble of manually validating the correctness of transition tables.

On ubuntu,
	$ sudo apt-get install graphviz

On linux,
	$ sudo yum install graphviz


2. Compilation and Execution:
=============================
Run run.sh script which expects p1.in and p4.in to be already present.
p1.in should contain regular expression.
p4.in should contain strings to match against DFA built for regular expression in p1.in

	$ sh run.sh

3. Building visual graphs:
==========================

Run graph.sh to convert nfa.dot, dfa.dot, mindfa.dot files generated by run.sh into visual representation.

	$ sh graph.sh

4. Approaches for each phase:
=============================

Phase 1: Regular Expression to NFA
----------------------------------
Two states are created as soon as a literal is seen and the resulting states are saved in state stack.
Whenever unary operator is seen, states are pulled out of state stack and combined them using Thompson's construction.
Whenever binary operator is seen, operator is pushed to an operator stack.
Whenever right-parenthesis is seen, states from state stack are evaluated based on operator stack until left-parenthesis is seen.
When string is completely processed, state stack is processed until operator stack is empty.

When operator stack is empty, state stack would be left with two states - start and final.

Phase 2: NFA to DFA
-------------------
As epsilon closure and symbol closure requires various groupings of NFA states. 'set' operations are implemented using 64-bit bitmasks.
This limits the maximum number of states to 64.

Phase 3: DFA to Min-DFA
-----------------------
Grouping states based on their 'set' equivalence also requires 'set' operations and so used 64-bit bitmasks.

Phase 4: String Acceptor
------------------------
Strings are parsed symbol by symbol till the end and checked if it reached any of the final states.

5. Limitations:
===============

-- Only regular expressions that can use up-to maximum of 64 states are supported because of 'sets' implementation using bitmasks.
-- There are certain invalid regular expressions for which NFA is correctly built, but during NFA-to-DFA conversion phase, epsilon closure goes into infinite loop because of bidirectional epsilon moves between two states.
